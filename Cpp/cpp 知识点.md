#cpp 基础知识点
- 宏指令注释的方式
	```cpp
	#if 0
	//code_body
	#endif
	```

- 换行符
	- endl
		- 换行并清空缓冲区
	- '\n'
		- 占一个字符，成为换行符
		- 换行但不清空缓冲区
	- 理论上endl速度要比\n慢一点，但实际上这种区别无法感知

- 在cpp中，普通字符指针不能只想字符串常量
	- 常量字符串位于字符常量区，生命周期同主线程
	- 例如 char* p = "12345";          //error
	- 改为 const char *p = "12345";    //correct

- namespace:
	- 可以用不同的命名空间存放相同的变量或者函数等数据类型
	- **但是命名空间的名字不可以重复**
	- 定义方式
	```cpp
		namespace
		{
			//code_body
		}
	```
	- 可以用using namespace xxx;调用命名空间，但是调用要在定义后面
	- 当两个命名空间中有相同的数据类型的时候，及时调用了命名空间，在使用的时候仍然需要加作用域运算符(::)表名命名空间
	- 使用命名空间中特定的数据类型的时候也可以用using
		- 比如使用std中的endl
			- using std::endl;
			- 此时在下文中使用endl的时候，不需要用命名空间修饰，但是其他的数据比如cin/cout前面仍然需要加std::修饰

- struct
	- cpp中申明结构体变量的时候，只需要使用结构体名字就可，不需要加struct，C语言中如果想去掉struct可以用typedef重命名。
	- cpp的结构体中，可以定义函数。
	- cpp中的结构体实际上是一个特殊的类，且访问限制修饰符为public

- new/delete
	- 申请单个空间
		- int *p = new int;	前后类型要匹配上
		- int *p = new int(15); 可以直接进行初始化，形式和C#相似
	- 申请连续空间
		- int *p = new int[5];
		- int *p2 = new int[5]{ 1,2,3,4,5 }; 也可以直接进行初始化
		- delete[] p2; -- 释放数组的时候，delete后面要加方括号
		- delete NULL是安全的，但是free(NULL)会崩溃
	- 和malloc和free的区别
		- new和delete在创建对象的时候可以出发构造函数和析构函数，malloc和delete是不可以的
		- 对普通的数据类型，两者没有什么区别

- *的三种作用
	- 定义指针
		- int *p = NULL;
	- *+地址，表示地址操作符 -- 操作内容
		- *p = 12;
	- 数字*数字 -- 表示乘法运算
		- 12*12

- 对内存的操作
	- 读/写/取地址

- 引用变量
	- 引用是已经定义的变量的别名(另一个名称)，两者的用法完全一样了。
	- typedef -- 是个类型起别名
		- 类型  变量;
	- int &c = a; //c是变量a的一个引用，c是变量a的一个别名
	- 定义了引用之后，这两个之间的有一个变量发生改变，另一个也发生改变
	- 定义的时候一定要初始化，定义了之后就不可以改变引用对象了。
	- 一个变量可以被多个变量引用
	- 引用也可以引用引用
	- 常量的引用
		- const int &n = 12;
		- const char &c = 'a';
		- const float &f = 12.34f;
		- 引用不可以改变值
	- 复合数据类型的引用
		- 数组的引用
			- 先确定是一个引用，在确定所引用的类型
			- int (&r)[12] = arr;	//int arr[12];
			- 其中方括号中的元素个数一定要说明
			- int (&rt)[2][3] = ar;	//int ar[2][3];
			- Node  &n = node;	//结构体的引用
			- int *(&rp) = point; 	//其中point是一个指针
				- rp的指向可以改变，rp的指向变了，point的指向也变了
	- 引用与函数
		- void fun(int &a);
			- 在调用的时候直接写fun(b);即可，不用加&，那是取地址，不是传引用
		- 引用做返回值
			```cpp
			int a = 12;
			int& fun1()
			{
				//int a = 12;
				return a;
			}
			```
			- 注意：不要返回局部变量的引用，函数结束后，局部变量会被销毁
	- 引用和指针的区别
		- 引用声明的时候就要初始化，指针可以不用
		- 引用初始化了之后就不可以引用其他空间了，而指针可以指向其他空间的
		- 引用不占用内存空间，指针占空间
		- 引用效率更高，指针是间接操作
		- 引用更安全吗，指针可以偏移
		- 指针更灵活，直接操作地址，指针更通用C/C++都行
	- &的三种作用
		- 声明变量的时候，&表示yiny
		- 变量前面加&，表示取地址
		- 数&数，表示位运算中的按位与运算

- for(int i=0;...);增强for循环中i的作用域只限定于for循环的语句块

- 函数参数指定默认值(缺省值)
	- void fun(int a=0, char c='\0');
	- 函数参数的默认值可以全部指定，可以部分指定，也可以不指定
	- 对于部分指定，指定的全是放在右边的参数，左边的参数不指定
	- 调用
		- 有默认值的参数可以传参也可以不传参
		- 没有默认值的参数必须要传参
	- 注意：含有默认值参数的函数声明是，声明处加默认值，定义处不加

- 函数重载
	- 同一作用域中，函数名字相同，参数列表不同的函数，互为重载函数
	- 重载函数在参数是float的时候，形参后面一定要加f
	- 同一作用域
		- 主函数之前的定义
	- 返回值不作为参数重载的条件
	- 函数重载仅限于参数的不同
	- 默认参数和重载结合使用可能造成重载不明确
		- void fun();
		- void fun(int a = 12);
		- 调用：fun();
		- 此时无法确定到底调用的是哪一个;

- 防止头文件重复包含
	- 预处理指令#pragma once
		- 这个指令的移植性略差，可能存在编译器不识别这种指令