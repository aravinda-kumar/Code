# C语言笔记
- 表达式
    - 表达式是一种有值的语法结构，它由运算符将变量，常量，函数调用的返回值结合而成。
    - 每个表达式一定有一个值
- 变量常量表达式
    - 例子
        - a, 12, 12.4
    - 值
        - 就是变量或者变量本身的值
        - 作为条件的时候
            - 非0即真，0即假
- 算数表达式
    - 例子
        - a+b, c*d+a, 12/3+d, i++, --a
    - 值
        - 就是计算的结果
        - 作为条件的时候
            - 非0即真，0即假
- 赋值表达式
    - 例子
        - a=12, a+=12, a=c=d
    - 值
        - 赋值完毕的结果的值
        - 作为条件的时候
            - 非0即真，0即假
- 关系表达式
    - 例子
        - a>b, 2==3
    - 值
        - 1, 0
        -作为条件的时候
            - 非0即真，0即假
- 逻辑表达式
    - 例子
        - a&&b, c||d, !a
    - 值
        - 1, 0
        - 作为条件的时候
            - 非0即真，0即假
- 复合表达式
    - 例子
        - x=(y=(a+b+a>4), z=10)
    - 值
        - 依据运算符的优先级和结合性得到结果
        - 作为条件
            - 非0即真，0即假
- 逗号表达式
    - 例子
        - (1, 2, 3, 4, a)
        - c = (a=2, 4, b=a) //a=b=c=2
    - 值
        - 最右侧的值就是逗号表达式的结果
        - 作为条件的时候
            - 非0即真，0即假
- 其他的
    - 有返回值的函数
    - 其他运算符
- 语句
    - 表达式+;

- 下标运算的操作
    - 2[p]==p[2]
    - 下标运算只在乎地址值是否有效，无论是数字还是指针在前。
    - 此种场景指适合到指针的情况，但不常用。
    
- 指针的大小
    - 指针在32位系统是4字节，在64位系统中是8字节---则句话不准确
    - 32位的系统支持32位的软件，64位的系统支持64和32位的软件。
    - 32位的程序/软件是4字节指针，64位程序/软件是8字节指针
    - 所以32位系统最大支持4字节指针，64位系统最大支持8字节指针---一个字节8位
    - 指针不分类型，同一个环境下，所有指针类型占用的字节数相同
    
- 内存的分区
    - 分区的意义
        - 工作分发会有针对性，效率会得到提示
    - 栈区
        - 我们定义的变量和数组都是在内存的栈区存储
        - 有些所说的堆栈就是栈区
        - 内存由操作系统申请，在生命周期结束时由系统释放
            - 生命周期
            - 定义到释放，不是所有变量在程序结束时才释放
            - 默认1M大小
    - 堆区
        - malloc的空间
        - 堆区的变量由程序员随时申请，随时释放, 不释放的话，也是和程序共存亡
    - 全局区
        - 也称，静态全局区
        - 全局变量，static
        - 特点
            - 会被自动初始化为0；
            - 生命周期和程序共存亡
            - 作用域 --- 全局static，限定于本文件，局部等价于局部变量, 普通全局变量，完全项目可见
    - 字符常量区
        - 12 'c', "qwe", 12.3
        - 特点
            - 只读
            - 空间也是由系统申请和释放
            - 生命周期
                - 字符串常量
                    - 从定义位置开始， 与程序共存亡
                - 数值常量
                    - 12 3.4 'c'
                    - 立即数存储，一般不占用存储空间
        - 全局const变量存储在常量区，局部const不在常量去，在栈区 
    - 代码区
        - 存放代码
        - 特点
            - 只读
            - 由系统管理
        
    
- 指针注意事项
    - 指针在使用前需要检查是否为空
    - 指针释放后需要赋值位NULL
        - 指针赋值位NULL了，称为空指针
        - 所指向的空间访问受限的指针叫做野指针
        
- []的三种作用：
    - 声明变量的时候由[]，表明声明的是数组变量。
    - 函数参数由[]，此时表示指针。
    - 地址+[]，表示下标运算。
    
- _getch()
    - 随输入随读取，不需要回车确认
    - 头文件是 conio.h
    - vs专用函数，gcc无法测试
    
- 字符串
    - 以'\0'结尾的字符数组
    - 转义字符---'%s'
        - 输出原理
            - 从给定的字符串地址开始，一个一个的输出，直到遇到'\0'即结束。
    - 使用scanf_s输入字符是，字符个数需要减一，为'\0'留有一个空间。
        - scanf_s只读入相应的个数，当输入个数超出的时候，后面的内容将直接忽略
    - gets_s输入字符是，字符个数需要减一，为'\0'留有一个空间。
    - 汉字
        - 一个汉字是两个字节，一个char是装不下的，需要两个char所以只能用字符串。

- 系统读数据的时候从高位开始

- 转字符
    - 认识
        - 转义字符 \
            - \a 警报
            - \b 退格
            - \n 换行
            - \r 回车 --- 不同于回车，将输入光标移到开头位置
            - \t 水平制表符
        - 转换说明符 %
            - % 有符号十进制数
    - 长度
        - 可以用strlen测试
        - 转换说明符是2个字节
        - 转义字符是1个字节
            - \+字母
                - 即使是未定义的转义字符，那也是1个字节
            - \+数字
                - \+数字      (1~3个)  0~377   是8进制    对应10进制的 0~255
                - \+0+数字    (1~2个)  0~77    是8进制    对应10进制的 0~63
                - \+x+数字    (1~2个)  0~ff    是16进制   对应10进制的 0~255
                - 这些是1个字节，超出了这个范围就不一定了

- 全部变量默认初始化0，局部变量初始化随机

- 隐式类型转换
    - 当出现在表达式中，有符号和无符号的char和short会被自动的转换成int参与运算，当short与int一样的时候，unsigned short被转换成unsigned int
    - 包含两种数据类型的任何运算中，两个值都会被转换成两种类型中较高的类型的，然后再计算。
         - long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int, int
         - 在long和int有相同类型大小的时候，unsigned int > long
         - 排名没有涉及到char short,因为已经被默认转换成int 或者unsigned int了
         - 混合运算的转换过程 --- 2+4/5.0f+6-9.0
            - 4.0f/5.0f = 0.8f  ==> 2+0.8f+6-9.0
            - 2.0f+0.8f+6-9.0 ==> 2.8f+6-9.0
            - 2.8f+6.0f-9.0 ==> 8.8f-9.0
            - 8.8d - 9.0d = -0.2d
            - 因此，类型转换不是一下子全部转换成double。转换过程是一步一步转换计算的。
    - 在赋值语句中，会被转换出赋值运算符左侧的类型，可能升级，也可能降级。
        - int a = 12.23 --- double被转换成int, double被降级
        - double d = 12 --- int被转换出double, int被升级
    - 作为函数参数的时候，char和short会被转换成int，float会被转化成double，可以通过函数原型防止类型提升。

- 显示类型转换
    - 强制类型转换
        - (type)+数据
        - 强转基本数据类型
            - 12 + (int)12.2
        - 强转指针类型/强转地址类型
            - 注意点：
                - 指针的类型，决定了指针的读写方式
                - 别越界
            - int a = 12; double *p; p = (double *)&a; *p = 12; --- 不允许，出现了越界，int只有4字节，指针p操作了8字节
            - double a = 12; int *p; p = (int *)&a; *p = 12; --- 允许，操作没有出现越界。
            - int a = 12; float *p; p = (float *)&a; *p = 12.12; --- 允许，数据类型占用字节数相同，不会出现越界。
            - 指针/地址的类型决定着指针/地址的读写方式。

- 大小端存储
    - 小端存储：数据的低位对应内存的低位。   --- 通常都是小端存储
    - 大端存储：数据的低位对应内存的高位。

- 重命名 --- typedef
    - 基本数据类型
        - typedef int myint;
            - myint就是int, 用起来没有任何区别
        - typedef unsigned int uint;
    - 注意:
        - 定义的位置决定作用范围
        - 同一个类型的重命名可以一样的名字，不同的就出问题了
    - 指针类型
        - type int* pint;
    - 结构体类型
        - typedef struct Node{ int x;}_Node; --- 后面的变量可以直接用_Node定义
        - typedef struct { int x;}_Node;     --- 在定义以外的地方也可以使用_Node定义变量
    - 函数指针类型
        - typedef void (*pFun)(int a, double d);
        
- 宏 --- #define
    - 理解 --- enum是给整数重命名，typedef是给类型重命名，宏是可以给一切重命名，但本质还是替换
    - 本质 --- 单纯的替换
    - 写法 --- #define 预处理指令
    - 常量宏
        - 将常量替换 #define ONE 1
            - 如果写成#define ONE 1; 1后面的分号也会被替换到相应位置，会产生错误!
        - 宏不进行任何运算，只是单纯的替换。
        - 对语句进行替换 --- #define PRINT printf("hello world!");
            - 此时语句结尾是否加分号取决于调用语句怎么写。
        - 可以定义空宏 --- #define THREE
        - 宏也可以作为宏的本体 ---  #define ONE 1 #define ONEONE ONE
        - 宏表达式进行计算的时候，注意运算的优先级，建议一般需要增加小括号
            - 例： #define ONE 1+1    2xONE = 2x1+1=3
            - 如果说想计算得到4, 可以在宏中加一个括号 --- #define ONE (1+1)
    - 参数宏
        - 传递参数 #define PRINT(x) printf("%d\n", x*2);
            - 宏的参数没有指定类型，但是仍然需要符合替换的语句中要求的数据类型
            - 传递的结果涉及到表达式的时候，仍然需要加小括号
                - PRINT(2+2) --- 结果会变成6
        - 传递多个参数 #define PRINT(x, y) printf("%d, %d\n", (x)*2, y);
    - 宏拼接 --- \
        - 反斜杠后面不可以加任何字符，包括空格，回车
        - 反斜杠的下一行可以加空格
    - 字符串指示符 --- #
        - 例子 #define NUM(x) #x
            - 包括双引号也会被解释成字符串，小括号里传什么，就转换什么
    - 字符串拼接符 --- ##
        - 例子 #define CATA(x, y) #x ## #y    printf("%s\n", CATA(123, 456));
        - 注意： 这个用法只在VS中可用
            
- 预处理指令 #include的作用
    - 在编译过程中起作用(预编译期)
    - 本质
        - 单纯的替换
    - 作用
        - 让声明更加方便
    - 双引号 --- 先在工程目录下找，如果工程目录下没有就去环境路径下去找
    - 尖括号 --- 直接到环境路径下去找
    - 头文件名称可以放置文件的绝对路径
    
- 多文件的时候.c文件不一定需要同名的.h文件，.h文件中包含函数声明即可，编译时系统会自动到所有.c文件中寻找函数实体
    - .h文件中只可以进行声明，不可以进行定义，定义需要到.c文件中
    
- 结构体相互引用
```
    struct GG;
    struct HH;
    
    struct HH
    {
        //GG没有实体，无法分配空间
        //报错
        struct GG g;
        int a;
    };
    
    struct GG
    {
        struct HH h;
        int a;
    };
```
    - 结构体不能相互嵌套
    - 如果实在想嵌套，可以使用指针；
```
    struct HH
    {
        //GG没有实体，无法分配空间
        struct GG *g;
        int a;
    };
    
    struct GG
    {
        struct HH h;
        int a;
    };
```
    - 结构体不能包含自己的实例，但可以使用指针 --- 链表
    
- 存储类说明符
    - 自动变量 --- auto
        - 也称为，局部变量，栈区变量
            - 定义在{}内
                - {}指代码段
                - 比如函数内等等
                - **结构体花括号可不是局部变量的意义，结构体的花括号最后有一个分号**
            - 种类
                - int a
                - int a[4]
                - int *p
                    - malloc申请的是空间不是变量
                - struct AAA;
        - 特征
            - 生命周期
                - 所在花括号，花括号结束，该变量被自动释放
            - 作用域
                - 所在花括号，出了花括号，名字就没有用了。
            - 所以叫局部变量，局部起作用。
        - 注意
            - auto
                - 默认是auto，不写和写是一样的
            - 函数不能返回局部变量的值
            - 同一个作用域中，变量名不能重复
            - 不同作用域中，变量名可以重复
                - 作用域嵌套是，最内层的变量起作用，外层的被忽略，实际上两者只是名字相同，内存空间是独立的
                - 作用域相互独立时，那就没有任何关系了。
    - 静态变量 --- static
        - 特点
            - 内存区域
                - 静态区/静态全局区/静态存储区
            - 内存特点
                - 会被自动初始化为0
                - 生命周期与程序共存亡
                - 运行时，在加载资源阶段分配空间
        - 全局变量/外部变量
            - 位置 
                - 写在全局的位置，定义在main函数外部
                - 全局变量会被初始化位0
                - 全局变量和局部变量重名，在局部位置，局部变量有效
                - 注意点
                    - 不能写执行语句，只能定义，初始化也只能使用常量进行初始化，也不可以在全局位置使用初始化了的全局变量给未初始化的全局变量初始化
            - 生命周期
                - 与程序共存亡
            - 作用域
                - 所有位置皆可见，包括其他文件
                - 跟函数一样只能出现一个定义，但声明可以出现多个
            - 注意：
                - 定义是不可以写在头文件里的，定义必须放在源文件里，除非没有初始化，此时可以放在头文件里
            - extern
                - 存储类说明符
                    - 修饰变量或者函数，表示这是一个外部变量，实体在别处，在全局的位置extern是否添加无意义，一般在声明的时候加一个extern
                - 修饰函数
                    - 在声明别的文件的时候，加一个extern
                - 修饰变量
                    - 全局变量本省就是对外开放的，所以加不加都行
                    - 在局部位置声明局部变量 --- extern int a;
                        - 如果不加extern的话，这就是在局部位置定义重名变量
                        - 这个不能定义，只能声明，表示a比那辆使用的是全局变量           
        - 静态全局变量
            - 生命周期
                - 与程序共存亡
            - 作用域
                - 只在所在文件有效，别的文件不好使
        - 静态全局变量只在当前文件可见，全局变量在整个项目里的所有文件可见
        - 静态局部变量
            - 局部静态变量
                - 在局部位置定义的静态变量
                - 默认初始化为0
                - 只能用常量进行初始化
            - 生命周期
                - 与程序共存亡
                    - 相当于把局部变量的生命周期加长了
                    - 内存修改特点
            - 作用域
                - 和局部变量作用域相同
                - 不同的作用域可以同名
                    - 嵌套作用域，内部覆盖外部
                    - 独立作用域，相互之间无关
            - static int a = 1; --- 这句话只是在程序刚开始执行一次，后面这句话就不起作用了
        - 静态函数
            - 在函数前面加一个static
            - 作用域
                - 只能在定义文件里使用，其他文件无法使用该函数
    - 寄存器变量 --- register
        - 修饰局部变量
        - register int a
            - 无法取地址 --- 这个变量定义在CPU中，所以无法取地址
            - 不可以修饰全局变量
        - cpu取数据处理
            - 寄存器   --- 寄存器和cpu速度相当，空间较小在kb级别
            - 高速缓存(1级, 2级, 3级)   --- 高速缓存速度比寄存器速度慢，但空间可以达到Mb
            - 物理内存 --- 内存比缓存要慢，但是空间可以达到GB级别
            - 硬盘    --- 速度更慢，但空间更大
            - 其他外设 --- USB外界存储器之类，速度一般更慢
        - 所以说这个寄存器变量就是指示系统直接将此变量存在寄存器中
            - 但是，由于这个寄存器可用空间非常珍贵，不是你普通人能决定的，所以即使我们使用了register，那系统也不一定让我们使用寄存器，
            它会根据当前系统的运行状态自动决定，基本就是给分配到内存中了，或者说register失效了，所以这个说明符基本用不到。
    - typedef
        - 存储类说明符, auto, extern, static, register, typedef
        - 一个变量不能出现两个存储类说明符
- 类型限定符
    - const
        - 一般也叫常量修饰符
            - 被修饰的变量就变成常量了，不能被二次修改了
        - 修改基本数据类型变量
            - const int a = 12;
                - const修饰之后a就变成了常量，不允许再被修改；
                - 定义的时候必须被初始化；
            - 等价于 int const a = 12;
            - 作用
                - 保护数据，增加数据的鲁棒性
            - 不可以通过a更改内容，但是可以根据地址进行更改；
        - 修饰数组
            - const int a[3] = {12, 13, 14};
            - 等价于 int const a[3] = {12, 13, 14};
            - 无法通过下标来更改元素了，但是通过地址仍然可以
        - 修饰指针
            - const int *p;
                - *p不可以修改指向的地址的值
                - 但是p的指向可以改变
            - int const *p; 同上
            - int* const p;
                - *p可以修改指向的地址的值
                - 但是p的指向不可以变
            - int const *const p;
                - 此时p的指向不可变，*p的内容也不可以通过p来改变
            - const int* const p; 同上
        - 作为函数参数，函数返回值
            - const int* fun(const int *p);
        - 标准来说
            - char *p = "asd"; ==> const char *p = "asd";
            - 加了const之后，在想用指针更改的时候，会报错
            - 不加的话，不会报错，但运行会崩溃
    - volatile --- 易变的变量
    - restrict --- 可优化的操作
        - 只能用于指针，表示该指正是访问对应的唯一且初始化的方式
        - int * restrict p = (int*)malloc(sizeof(int)*5);
            
- 命令行参数
    - 意义
        - 通过带有参数的主函数参数，传递命令行参数，
        - int main(int argc, char* argv[])
    - 作用
        - 将应用程序的外部数据传递进主函数内部进程处理，就是用到命令行参数，一般传递的是文件路径
    - int main(int argc, char* argv[])
        - 标准命令行参数
        - 第一个参数是命令行参数的个数
        - 第二个参数是一个字符串数组，用来传递命令
        - argv[0]就是当前的执行目录
        - 可以通过循环来显示各个参数
    - 形式
        - 传递参数
            - 通过控制台传递
                - 将exe文件拖到控制台，后面接参数，参数之间用空格隔开
                - 控制台又叫命令行，输入指令的，所以这里传递的参数，就叫命令行参数
            - 通过编译器传递
                - 工程属性 -> 调试 -> 命令行参数 用空格隔开
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            