# C语言笔记
- 表达式
    - 表达式是一种有值的语法结构，它由运算符将变量，常量，函数调用的返回值结合而成。
    - 每个表达式一定有一个值
- 变量常量表达式
    - 例子
        - a, 12, 12.4
    - 值
        - 就是变量或者变量本身的值
        - 作为条件的时候
            - 非0即真，0即假
- 算数表达式
    - 例子
        - a+b, c*d+a, 12/3+d, i++, --a
    - 值
        - 就是计算的结果
        - 作为条件的时候
            - 非0即真，0即假
- 赋值表达式
    - 例子
        - a=12, a+=12, a=c=d
    - 值
        - 赋值完毕的结果的值
        - 作为条件的时候
            - 非0即真，0即假
- 关系表达式
    - 例子
        - a>b, 2==3
    - 值
        - 1, 0
        -作为条件的时候
            - 非0即真，0即假
- 逻辑表达式
    - 例子
        - a&&b, c||d, !a
    - 值
        - 1, 0
        - 作为条件的时候
            - 非0即真，0即假
- 复合表达式
    - 例子
        - x=(y=(a+b+a>4), z=10)
    - 值
        - 依据运算符的优先级和结合性得到结果
        - 作为条件
            - 非0即真，0即假
- 逗号表达式
    - 例子
        - (1, 2, 3, 4, a)
        - c = (a=2, 4, b=a) //a=b=c=2
    - 值
        - 最右侧的值就是逗号表达式的结果
        - 作为条件的时候
            - 非0即真，0即假
- 其他的
    - 有返回值的函数
    - 其他运算符
- 语句
    - 表达式+;

- 下标运算的操作
    - 2[p]==p[2]
    - 下标运算只在乎地址值是否有效，无论是数字还是指针在前。
    - 此种场景指适合到指针的情况，但不常用。
    
- 指针的大小
    - 指针在32位系统是4字节，在64位系统中是8字节---则句话不准确
    - 32位的系统支持32位的软件，64位的系统支持64和32位的软件。
    - 32位的程序/软件是4字节指针，64位程序/软件是8字节指针
    - 所以32位系统最大支持4字节指针，64位系统最大支持8字节指针---一个字节8位
    - 指针不分类型，同一个环境下，所有指针类型占用的字节数相同
    
- 内存的分区
    - 分区的意义
        - 工作分发会有针对性，效率会得到提示
    - 栈区
        - 我们定义的变量和数组都是在内存的栈区存储
        - 有些所说的堆栈就是栈区
        - 内存由操作系统申请，在生命周期结束时由系统释放
            - 生命周期
            - 定义到释放，不是所有变量在程序结束时才释放
    - 堆区
        - 堆区的变量由程序员随时申请，随时释放
    - 全局区
    - 字符常量区
    - 代码区
    
- 指针注意事项
    - 指针在使用前需要检查是否为空
    - 指针释放后需要赋值位NULL
        - 指针赋值位NULL了，称为空指针
        - 所指向的空间访问受限的指针叫做野指针
        
- []的三种作用：
    - 声明变量的时候由[]，表明声明的是数组变量。
    - 函数参数由[]，此时表示指针。
    - 地址+[]，表示下标运算。
    
- _getch()
    - 随输入随读取，不需要回车确认
    - 头文件是 conio.h
    - vs专用函数，gcc无法测试
    
- 字符串
    - 以'\0'结尾的字符数组
    - 转义字符---'%s'
        - 输出原理
            - 从给定的字符串地址开始，一个一个的输出，直到遇到'\0'即结束。
    - 使用scanf_s输入字符是，字符个数需要减一，为'\0'留有一个空间。
        - scanf_s只读入相应的个数，当输入个数超出的时候，后面的内容将直接忽略
    - gets_s输入字符是，字符个数需要减一，为'\0'留有一个空间。
    - 汉字
        - 一个汉字是两个字节，一个char是装不下的，需要两个char所以只能用字符串。

- 系统读数据的时候从高位开始

- 转字符
    - 认识
        - 转义字符 \
            - \a 警报
            - \b 退格
            - \n 换行
            - \r 回车 --- 不同于回车，将输入光标移到开头位置
            - \t 水平制表符
        - 转换说明符 %
            - % 有符号十进制数
    - 长度
        - 可以用strlen测试
        - 转换说明符是2个字节
        - 转义字符是1个字节
            - \+字母
                - 即使是未定义的转义字符，那也是1个字节
            - \+数字
                - \+数字      (1~3个)  0~377   是8进制    对应10进制的 0~255
                - \+0+数字    (1~2个)  0~77    是8进制    对应10进制的 0~63
                - \+x+数字    (1~2个)  0~ff    是16进制   对应10进制的 0~255
                - 这些是1个字节，超出了这个范围就不一定了

- 全部变量默认初始化0，局部变量初始化随机

- 隐式类型转换
    - 当出现在表达式中，有符号和无符号的char和short会被自动的转换成int参与运算，当short与int一样的时候，unsigned short被转换成unsigned int
    - 包含两种数据类型的任何运算中，两个值都会被转换成两种类型中较高的类型的，然后再计算。
         - long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int, int
         - 在long和int有相同类型大小的时候，unsigned int > long
         - 排名没有涉及到char short,因为已经被默认转换成int 或者unsigned int了
         - 混合运算的转换过程 --- 2+4/5.0f+6-9.0
            - 4.0f/5.0f = 0.8f  ==> 2+0.8f+6-9.0
            - 2.0f+0.8f+6-9.0 ==> 2.8f+6-9.0
            - 2.8f+6.0f-9.0 ==> 8.8f-9.0
            - 8.8d - 9.0d = -0.2d
            - 因此，类型转换不是一下子全部转换成double。转换过程是一步一步转换计算的。
    - 在赋值语句中，会被转换出赋值运算符左侧的类型，可能升级，也可能降级。
        - int a = 12.23 --- double被转换成int, double被降级
        - double d = 12 --- int被转换出double, int被升级
    - 作为函数参数的时候，char和short会被转换成int，float会被转化成double，可以通过函数原型防止类型提升。

- 显示类型转换
    - 强制类型转换
        - (type)+数据
        - 强转基本数据类型
            - 12 + (int)12.2
        - 强转指针类型/强转地址类型
            - 注意点：
                - 指针的类型，决定了指针的读写方式
                - 别越界
            - int a = 12; double *p; p = (double *)&a; *p = 12; --- 不允许，出现了越界，int只有4字节，指针p操作了8字节
            - double a = 12; int *p; p = (int *)&a; *p = 12; --- 允许，操作没有出现越界。
            - int a = 12; float *p; p = (float *)&a; *p = 12.12; --- 允许，数据类型占用字节数相同，不会出现越界。
            - 指针/地址的类型决定着指针/地址的读写方式。

- 大小端存储
    - 小端存储：数据的低位对应内存的低位。   --- 通常都是小端存储
    - 大端存储：数据的低位对应内存的高位。

- 重命名 --- typedef
    - 基本数据类型
        - typedef int myint;
            - myint就是int, 用起来没有任何区别
        - typedef unsigned int uint;
    - 注意:
        - 定义的位置决定作用范围
        - 同一个类型的重命名可以一样的名字，不同的就出问题了
    - 指针类型
        - type int* pint;
    - 结构体类型
        - typedef struct Node{ int x;}_Node; --- 后面的变量可以直接用_Node定义
        - typedef struct { int x;}_Node;     --- 在定义以外的地方也可以使用_Node定义变量
    - 函数指针类型
        - typedef void (*pFun)(int a, double d);
        
- 宏 --- #define
    - 理解 --- enum是给整数重命名，typedef是给类型重命名，宏是可以给一切重命名，但本质还是替换
    - 本质 --- 单纯的替换
    - 写法 --- #define 预处理指令
    - 常量宏
        - 将常量替换 #define ONE 1
            - 如果写成#define ONE 1; 1后面的分号也会被替换到相应位置，会产生错误!
        - 宏不进行任何运算，只是单纯的替换。
        - 对语句进行替换 --- #define PRINT printf("hello world!");
            - 此时语句结尾是否加分号取决于调用语句怎么写。
        - 可以定义空宏 --- #define THREE
        - 宏也可以作为宏的本体 ---  #define ONE 1 #define ONEONE ONE
        - 宏表达式进行计算的时候，注意运算的优先级，建议一般需要增加小括号
            - 例： #define ONE 1+1    2xONE = 2x1+1=3
            - 如果说想计算得到4, 可以在宏中加一个括号 --- #define ONE (1+1)
    - 参数宏
        - 传递参数 #define PRINT(x) printf("%d\n", x*2);
            - 宏的参数没有指定类型，但是仍然需要符合替换的语句中要求的数据类型
            - 传递的结果涉及到表达式的时候，仍然需要加小括号
                - PRINT(2+2) --- 结果会变成6
        - 传递多个参数 #define PRINT(x, y) printf("%d, %d\n", (x)*2, y);
    - 宏拼接 --- \
        - 反斜杠后面不可以加任何字符，包括空格，回车
        - 反斜杠的下一行可以加空格
    - 字符串指示符 --- #
        - 例子 #define NUM(x) #x
            - 包括双引号也会被解释成字符串，小括号里传什么，就转换什么
    - 字符串拼接符 --- ##
        - 例子 #define CATA(x, y) #x ## #y    printf("%s\n", CATA(123, 456));
        - 注意： 这个用法只在VS中可用
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            