# cpp 多态与虚函数

- 多态是一种泛型编程的思想
	- 同样的代码实现不同的功能
	- 父类的指针调用子类的函数
- 虚函数是实现这个思想的语法基础
- 父类的指针指向子类的空间
	- CFather *fa = new CSon;
	- 一般父类的指针只能访问父类的成员
	- 当父类中的完全相同的函数，包括参数列表和返回值，声明为virtual的时候，父类的指针则调用子类的函数
- 多态的形式
	- virtual void fun();
	- 子类的函数要和父类的虚函数完全相同
	- 多个子类的时候，调用指向的子类的函数
	- 多态针对于指针的对象
- 多态，即父类的一个指针可以有多重执行执行状态或者结果，则成为多态。
- 特点
	- 重写
		- 父类和子类相同，父类是虚函数，叫做重写
		- 虚 只针对于函数
		- 子类重写的函数，默认是虚函数，可以显式加virtual，也可以不加
		- 名字参数相同
			- 返回值一般也要相同。
			- 返回值不同是协变，父类的返回值是父类的引用，子类也返回子类的引用。return *this;
	- 虚函数不是内联函数，普通成员函数默认是内联函数。
	- 构造函数不能是虚函数
- 虚表
	- 放置虚函数地址的列表，每个子类都会有一个属于自己的虚表
	- 虚函数覆盖原理
	- 取虚表地址以及内容
		- 对象空间的最开始四个字节的内容，就是虚表的地址，叫虚指针
		- 流程
		```cpp
		class CFather
		{
		public:
			virtual void Fun()
			{
				cout << "Class CFather Fun" << endl;
			}
			virtual void Show()
			{
				cout << "Class CFather Show" << endl;
			}
		};

		class CSon:public CFather
		{
		public:
			int aa;
			void Show()
			{
				cout << "Class CSon Show" << endl;
			}
		};
		//CFather *fa = new CSon;
		//(int*)fa                             -- 取CSon的前四个字节的地址
		//*(int*)fa                            -- 取CSon的前四个字节的内容 -- 即虚表的地址
		//(int &)*(int*)fa                     -- 取虚表的四个字节的地址
		//*((int &)*(int*)fa+0)                -- 取虚表前四个字节的内容 -- 函数的地址
		//(void(*)())(*((int &)*(int*)fa+0))   -- 将指针转换成函数指针
		//(void(*)())(*((int &)*(int*)fa+0))() -- 调用函数指针的内容即调用函数
		```
- 虚析构
	- delete哪个类型的指针就调用哪个类的析构
	- 父类的普通析构在多态的时候只调用父类的析构函数
	- 父类的虚析构函数在多态的时候会调用父类和子类的析构函数，先子类析构后父类析构
- 纯虚函数
	- 形式
		- virtual void fun()=0;
		- 纯虚函数没有函数体，也不允许定义函数体
	- 抽象类
		- 类中有纯虚函数的时候，是不能实例化对象的
	- 继承这个基类的子类必须实现这个纯虚函数，此时子类才可以定义对象，或者用父类的指针指向子类,父类仍然不可以定义对象。
	- 接口类
		- 类中全是纯虚函数，但可以有构造函数、析构函数和成员等