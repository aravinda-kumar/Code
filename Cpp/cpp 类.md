# cpp 类

- 面向对象是一种编程思想

- 类是一个语法

- 类是一类具有想通属性和行为的对象的集合。类具有抽象特性。

- 示例

  ```cpp
  class CPeople
  {
  public:
    int a;
    void fun()
    {
        cout << "class CPeople" << endl;
    }
  };
  ```

- class CPeople{}; 类声明，和结构体一样，结尾需要有;

- 成员调用，类的所有成员，除了static成员外必须使用实例进行调用；
	- 类实际上是一种类型的定义
	- 编译器不会给类型分配空间

- public :访问修饰符
	- 类的默认访问修饰符是private
	- public
	- 类外可见
	- struct默认是public
- private
    - 类内可见
    - class默认是private
    - 私有成员的设置和获取可以通过接口来实现
- protected
    - 类内以及子类可见
- 访问修饰符的作用范围
    - 从书写位置开始，一直到下个修饰符，或者到类的结尾
	- 作为类内成员分类的工具，修饰符写多少都行
- 注重类的封装的安全性

- 友元
	- 关键字 -- friend
	- 友元不是直接是有类中的成员，而是通过实例来访问
	- 友元函数    -- friend void fun1();
		- 友元函数也可以使用类内的protected成员，即类内所有成员对友元均可见
		- **主函数也可以被声明成员友元函数**
	- 友元类
    	- 一个类想要使用另一个类的私有成员只能使用友元类
	- 特点
		- 不受访问修饰符的影响
		- 可以声明多个友元
		- 缺点：破坏了类的封装性，不到迫不得已不要使用友元

- 函数成员
	- 初始化时一个变量或者对象产生之时就赋予的一个值，伴随性质，赋值是变量或者对象在定义之后值随意更改的性质。
	- 函数可以在类内定义，也可以在类外定义，类外定义的函数在函数名前需要加类名作用域
	- 构造函数
		- 类的数据成员不可以在定义的时候初始化，静态数据成员除外
		- 因为类的定义是定义类型，不分配空间，所以无法初始化
		- 声明类的实例的时候，()代表调用含参构造函数
		- 构造函数没有返回值
		- 对象创建的时候，自动调用构造函数
		- 对于堆区的对象，声明指针的时候不会调用构造函数，只有在new的时候才会调用
		- 类中没有构造函数的时候，编译器会自动添加一个无参无函数体的构造函数
		- 无参构造函数和全默认值参数的构造函数不可同时存在
	- 初始化列表
		- 基本数据类型，构造函数和初始化列表都可以
		- 引用和const只能用初始化列表
		- 形式 -- 构造函数头:数据成员(数据),...
		- 如果花括号里面为空，花括号仍然需要保留。
		- 初始化列表在构造函数之前执行
		- 成员变量的初始化顺序遵循定义的顺序
		- 作用
			- 对数据成员进行初始化，构造函数是对数据进行赋值
			- 在类外定义函数是，初始化列表只能放在类外。
			- 初始化列表中可以使引用给引用赋值
		- 多个构造函数，初始化列表只执行对应的初始化列表
		- 数组和结构体使用初始化列表
			- 数组
				- CStu():arr();这种写法部分编译器支持
				- 在构造函数里，用循环单独赋值
				- memset(arr, 0, sizeof(type)*N)
			- 结构体
				- 结构体可以直接通过结构体之间相互赋值进行初始化
				- 使用初始化列表会比较复杂，可以直接使用构造函数
	- 析构函数
		- 析构函数只有一个，没有参数，没有重载
		- 默认析构函数的函数体为空，不进行任何操作
		- 对象在释放的时候自动调用的函数
			- 局部变量 -- 局部变量作用域结束的时候释放
			- 堆区指针对象 -- delete的时候释放对象
			- 堆区指针对象 -- 对象还是在作用域结束的时候释放
				- 临时对象 -- 进入当前行构造，离开当前行析构
			  	- 临时对象作用域仅限当前所在语句
			  	- 格式 类型(数据);
		- 作用：将类中new出来的空间进行delete释放
	- 常函数
		- 形式: void fun() const;
		- 构造函数和析构函数不可以是常函数
		- 特点：
			- 可以使用数据成员，不能修改数据成员，类中定义的数据成员修改为const，但是常函数中的数据变量可以修改
			- 常函数的this指针变成了const CStu*
			- 常对象只能调用常函数，不能调用普通函数
				- const CStu stu;
  - 静态成员
    - static int a;
    	- 类外进行初始化 -- int CStu::a = 12;
    	- 调用方法
        	- 作用域说明符调用 -- CStu::a;
        	- 通过对象调用 -- stu.a;
    	- 声明为private类外不可以使用
    	- 不使用循环实现变量的累加
    - **静态常量整形成员可以在类内直接初始化**
    	- 在类的构造函数中实现静态变量的累加，这样创建对象的时候就会调用构造函数，实现了静态变量的累加
    - static void fun();
    	- 调用方式
        	- 可以通过类名作用域调用 -- CStu::fun();
        	- 通过对象实例调用 -- stu.fun();
    	- 它是类的属性，所有的类公用一个
    	- 没有this指针 -- 可以通过类名作用域调用
    	- 静态成员函数不可以调用普通成员，只可以调用静态成员
    	- 可以作为一种指挥该类所有对象的作用

- 数据成员
	- this指针
    	- 作用：区分同名
    	- 指向当前对象的指针，可以调用类的成员
    	- this指针和创建的对象绑定，未创建对象的时候不含有这个指针。
    	- 类型，对应的类的指针
    	- this指针不是成员
    	- this作用域在类的函数内部，它是默认传给类的函数成员的一个隐含参数

- 拷贝构造
	- 形式 -- CStu(const CStu &a)
    	- 本质即构造函数
    	- 参数是本类的常引用
	- 何时调用
    	- 新建一个对象，并将其初始化为同类现有对象
			- CStu a; -- 声明一个对象
        		- CStu a1(a);
				- CStu a2 = a;
				- CStu a3 = CStu(a);
				- CStu *a4  = new CStu(a);
				- 注意：
					- 赋值不可以 -- CStu s; CStu p; p = s;
  	- 当程序生成对象副本的时候
  		- 函数参数传递的值
  		- 函数的返回值
	- 功能
		- 默认的复制构造函数，逐个复制非静态成员的值(成员的复制为潜复制)，复制的是成员的值
			- 系统默认的这个又叫浅拷贝
			- 同一个类的多个对象，内存排布是不一样的，地址不同
			- 默认的拷贝构造函数是有内容的，用来复制成员的值
	- 浅拷贝的问题
		- 指针成员
			- 进拷贝构造没有分配空间，只是把复制的对象的首地址进行复制。最后无法释放
		- 构造分配空间
		- 析构释放空间
		```cpp
			class CStu
			{
			public:
				int *a;
				CStu()
				{
					a = new int[3]{ 1,2 };
				}
				~CStu()
				{
					delete[] a;
				}
			};
			......
			CStu st;
			cout << st.a[0] << ' ' << st.a[1] << ' ' << st.a[2] << endl;
			cout << st.a << endl;

			//删除第二个指针的时候会引发中断
			CStu at = st;
			cout << at.a[0] << ' ' << at.a[1] << ' ' << at.a[2] << endl;
			cout << at.a << endl;

			//at.a == st.a
		```
	- 深拷贝
		- 指针成员不可以直接赋值，要用内存复制
	- 解决拷贝构造所引发的指针成员二次释放崩溃的问题的方式
		- 深拷贝
		- 传地址
		- 传引用

- 内联函数 -- inline
	- 函数声明和定义都要加inline
	- 作用：用相应的代码替换调用，比常规函数快，但是占用更多的内存
	- 程序猿将某一个函数请求作为内联函数的时候，编译器不一定会同意，不是标准，具体情况视不同编译器而定。
		- 原因：
			- 函数体过大
			- 递归函数不能是内联函数
			- 如果写了等于没写，按普通函数编译
	- 类与内联函数
		- 类内定义的函数都是内联函数
		- 类外定义的函数有inline才是内联，否则不是。
	- 内联函数与多文件
		- 内联函数一般都是定义在头文件里。